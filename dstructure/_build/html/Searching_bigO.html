
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Searching and Big O Notations &#8212; Data Structures in C++</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Sorting algorithms" href="Sorting_algorithms.html" />
    <link rel="prev" title="Why learn data structures?" href="Data_structures.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.svg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Data Structures in C++</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Welcome to Data Structures in C++
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Data_structures.html">
   Why learn data structures?
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Searching and Big O Notations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Sorting_algorithms.html">
   Sorting algorithms
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/docs/Searching_bigO.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/executablebooks/jupyter-book"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2FSearching_bigO.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/Searching_bigO.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#organization-of-data">
   Organization of data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#binary-search">
   Binary search
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#procedure">
     Procedure
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pseudocode">
     Pseudocode
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#comparison-of-linear-and-binary-search">
   Comparison of Linear and Binary search
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#big-o-notations">
   Big O Notations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#o-1-example">
     <span class="math notranslate nohighlight">
      \(O(1)\)
     </span>
     example
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#o-n-example">
     <span class="math notranslate nohighlight">
      \(O(n)\)
     </span>
     example
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#o-log-2n-example">
     <span class="math notranslate nohighlight">
      \(O(log_2n)\)
     </span>
     example
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bibliography">
   Bibliography
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Searching and Big O Notations</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#organization-of-data">
   Organization of data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#binary-search">
   Binary search
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#procedure">
     Procedure
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pseudocode">
     Pseudocode
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#comparison-of-linear-and-binary-search">
   Comparison of Linear and Binary search
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#big-o-notations">
   Big O Notations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#o-1-example">
     <span class="math notranslate nohighlight">
      \(O(1)\)
     </span>
     example
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#o-n-example">
     <span class="math notranslate nohighlight">
      \(O(n)\)
     </span>
     example
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#o-log-2n-example">
     <span class="math notranslate nohighlight">
      \(O(log_2n)\)
     </span>
     example
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bibliography">
   Bibliography
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="searching-and-big-o-notations">
<h1>Searching and Big O Notations<a class="headerlink" href="#searching-and-big-o-notations" title="Permalink to this headline">#</a></h1>
<p>In the last chapter, we discussed that several versions of the code might exist to achieve a task. However, some or just one version of the code may be efficient. Therefore, one of the units to measure the efficiency of a code is to calculate the number of steps required to achieve a desired result. We further explored that in a given data structure, the efficiency of a data structure varies with different operations, such as reading, searching, insertion, and deletion. In this chapter, we dive a little deeper and discuss what other factors can affect the performance of a code.</p>
<section id="organization-of-data">
<h2>Organization of data<a class="headerlink" href="#organization-of-data" title="Permalink to this headline">#</a></h2>
<p>Let’s extend our discussion about an array data structure. Assume that an array is filled with an integer data type with random elements with no repetition of elements. Let’s choose a real-world example - an array data structure filled with the last four digits of an SSN.
For simplicity reasons, assume that the array data structure is the best choice for storing the number. The figure shows the array with elements stored randomly. The user searches for a particular SSN in an array. The processor starts the search from index 0 and then continues to search until the desired element is found. If the data is the last element (worst-case scenario), the search traverses the entire array’s length. Hence, the number of steps in searching a data element of a worst-case scenario would be N, where N is the length of an array. On the contrary, inserting data into an array would require just one step. The new data appends at the end of the array and do not require any element shifting, see <a class="reference internal" href="#unsorted-array-insertion"><span class="std std-numref">Fig. 3</span></a></p>
<figure class="align-default" id="unsorted-array-insertion">
<a class="reference internal image-reference" href="_images/unsorted_array.png"><img alt="_images/unsorted_array.png" src="_images/unsorted_array.png" style="height: 150px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Insertion on a unsorted array</span><a class="headerlink" href="#unsorted-array-insertion" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Let’s extend the above assumption, but this time, the elements in the array are sorted. So, for example, if value 5245 is searched in an array, the search stops where the value is just greater than 5245; in this example, the search stops at index 4. This search is called a linear search.</p>
<div class="alert alert-block alert-info">
Linear search iterates over every element of the array, looking for the search value. The search stops as soon as the element it is iterating over is greater than the search value, since we know that the search value will not be found further within the array. 
</div>
<p>The following is the pseudocode of the basic linear search algorithm.</p>
<p>Given a list <span class="math notranslate nohighlight">\(L\)</span> of <span class="math notranslate nohighlight">\(n\)</span> elements with values or records <span class="math notranslate nohighlight">\(L_0\)</span> …. <span class="math notranslate nohighlight">\(L_{n−1}\)</span>, and target value <span class="math notranslate nohighlight">\(T\)</span>, the following subroutine uses linear search to find the index of the target <span class="math notranslate nohighlight">\(T\)</span> in <span class="math notranslate nohighlight">\(L\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">Set</span> <span class="n">i</span> <span class="n">to</span> <span class="mf">0.</span>
<span class="mf">2.</span> <span class="n">If</span> <span class="n">Li</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="n">the</span> <span class="n">search</span> <span class="n">terminates</span> <span class="n">successfully</span><span class="p">;</span> <span class="k">return</span> <span class="n">i</span><span class="o">.</span>
<span class="mf">3.</span> <span class="n">Increase</span> <span class="n">i</span> <span class="n">by</span> <span class="mf">1.</span>
<span class="mf">4.</span> <span class="n">If</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">,</span> <span class="n">go</span> <span class="n">to</span> <span class="n">step</span> <span class="mf">2.</span> <span class="n">Otherwise</span><span class="p">,</span> <span class="n">the</span> <span class="n">search</span> <span class="n">terminates</span> <span class="n">unsuccessfully</span><span class="o">.</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>Does linear search perform better when arrays are sorted over unsorted?</strong></p>
</div></blockquote>
<p>Unfortunately, the answer is no; under the worst-case scenario, the linear search would use the ‘N’ number of steps where ‘N’ is the number of elements in an array regardless of whether arrays are sorted or not sorted.</p>
<div class="alert alert-block alert-info">
The worst-case scenario is the situation or input that forces an algorithm or data structure to take the most time or resources.
</div>
<p>Furthermore, keeping the array in a sorted state before applying any search operation does require some processing. For example, inserting an integer value in an array does require comparison and shifting elements so that the new value goes into the correct place. The new number is compared with the each element in an array until the correct location is found, see <a class="reference internal" href="#sorted-array-insertion"><span class="std std-numref">Fig. 4</span></a></p>
<figure class="align-default" id="sorted-array-insertion">
<a class="reference internal image-reference" href="_images/sorted_array_insertion.png"><img alt="_images/sorted_array_insertion.png" src="_images/sorted_array_insertion.png" style="height: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Insertion on a sorted array</span><a class="headerlink" href="#sorted-array-insertion" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Based on the above discussion, linear search on sorted arrays does not improve performance. Furthermore, there is an overhead of sorting arrays, so why do we even bother sorting an array?</p>
<p>Indeed, the linear search algorithm is inefficient regardless of whether arrays are sorted or not. However, sorted arrays unlock other search algorithms, such as binary search, which works at a blazing-fast speed compared to linear search algorithms.</p>
</section>
<section id="binary-search">
<h2>Binary search<a class="headerlink" href="#binary-search" title="Permalink to this headline">#</a></h2>
<p>Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of the array with the target value. If the target value matches the element, its position in the array is returned. If the target value is less than the element, the search continues in the lower half of the array. If the target value is greater than the element, the search continues in the upper half of the array. By doing this, the algorithm eliminates the half where the target value cannot lie in each iteration.</p>
<p>See the animation<a class="footnote-reference brackets" href="#binarysearch" id="id1">1</a> of binary search algorithm.</p>
<section id="procedure">
<h3>Procedure<a class="headerlink" href="#procedure" title="Permalink to this headline">#</a></h3>
<p>Given an array <span class="math notranslate nohighlight">\(A\)</span> of <span class="math notranslate nohighlight">\(n\)</span> elements with values or records <span class="math notranslate nohighlight">\(A_0\)</span>,<span class="math notranslate nohighlight">\(A_1\)</span>,<span class="math notranslate nohighlight">\(A_2\)</span>,…,<span class="math notranslate nohighlight">\(A_{n-1}\)</span> sorted such that <span class="math notranslate nohighlight">\(A_0\)</span> <span class="math notranslate nohighlight">\(\leq\)</span> <span class="math notranslate nohighlight">\(A_1\)</span> <span class="math notranslate nohighlight">\(\leq\)</span> <span class="math notranslate nohighlight">\(A_2\)</span> <span class="math notranslate nohighlight">\(\leq\)</span> … <span class="math notranslate nohighlight">\(\leq\)</span> <span class="math notranslate nohighlight">\(A_{n-1}\)</span>, and target value <span class="math notranslate nohighlight">\(T\)</span>, the following subroutine uses binary search to find the index of <span class="math notranslate nohighlight">\(T\)</span> in <span class="math notranslate nohighlight">\(A\)</span>.<span id="id2">[<a class="reference internal" href="#id9" title="Donald Knuth. The Art of Computer Programming. Volume 3. Addison-Wesley Professional, 1998. ISBN 978-0-201-89685-5.">Knu98</a>]</span></p>
<ol class="simple">
<li><p>Set <span class="math notranslate nohighlight">\(L\)</span> to 0 and <span class="math notranslate nohighlight">\(R\)</span> to <span class="math notranslate nohighlight">\(n-1\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(L\)</span> <span class="math notranslate nohighlight">\(\gt\)</span> <span class="math notranslate nohighlight">\(R\)</span>, the search terminates as unsuccessful.</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(m\)</span> (the position of the middle element) to the floor of <span class="math notranslate nohighlight">\(L+R\over2\)</span>, which is the greatest integer less than or equal to <span class="math notranslate nohighlight">\(L+R\over2\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(A_m\)</span> <span class="math notranslate nohighlight">\(\lt\)</span> <span class="math notranslate nohighlight">\(T\)</span>, set <span class="math notranslate nohighlight">\(L\)</span> to <span class="math notranslate nohighlight">\(m+1\)</span> and go to step 2.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(A_m\)</span> <span class="math notranslate nohighlight">\(\gt\)</span> <span class="math notranslate nohighlight">\(T\)</span>, set <span class="math notranslate nohighlight">\(R\)</span> to <span class="math notranslate nohighlight">\(m-1\)</span> and go to step 2.</p></li>
<li><p>Now <span class="math notranslate nohighlight">\(A_m\)</span> = <span class="math notranslate nohighlight">\(T\)</span>, the search is done; return <span class="math notranslate nohighlight">\(m\)</span>.</p></li>
</ol>
<blockquote>
<div><p><strong>In mathematics and computer science, the floor function is the function that takes as input a real number <span class="math notranslate nohighlight">\(x\)</span>, and gives as output the greatest integer less than or equal to <span class="math notranslate nohighlight">\(x\)</span>, denoted <span class="math notranslate nohighlight">\(\lfloor x\)</span> <span class="math notranslate nohighlight">\(\rfloor\)</span> or floor<span class="math notranslate nohighlight">\((x)\)</span>. For example, the floor value of 3.7 is 3, because the number of integers less than 3.7, is 3, 2, 1, 0 and so on. So, the highest integer will be 3.</strong></p>
</div></blockquote>
</section>
<section id="pseudocode">
<h3>Pseudocode<a class="headerlink" href="#pseudocode" title="Permalink to this headline">#</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>function binary_search(A, n, T) is
    L := 0
    R := n − 1
    while L ≤ R do
        m := floor((L + R) / 2)
        if A[m] &lt; T then
            L := m + 1
        else if A[m] &gt; T then
            R := m − 1
        else:
            return m
    return unsuccessful
</pre></div>
</div>
</section>
</section>
<section id="comparison-of-linear-and-binary-search">
<h2>Comparison of Linear and Binary search<a class="headerlink" href="#comparison-of-linear-and-binary-search" title="Permalink to this headline">#</a></h2>
<p>The binary search does not provide a significant advantage over a linear search algorithm. In a linear search algorithm, if we are searching for a value that exists in the last cell of an array, then the search algorithm would iterate all the elements in an array. This case is an example of a worst-case scenario. The linear search takes N number of steps where N is the number of elements in an array. On the contrary, the binary search would take <span class="math notranslate nohighlight">\(log_2N\)</span> steps. The result of <span class="math notranslate nohighlight">\(log_2N\)</span> will be rounded up to the nearest decimal value. For example, if there are 100 elements in an array, the linear search would take 100 steps, whereas the binary search would finish the search in just 7 steps. The <a class="reference internal" href="#linear-binary"><span class="std std-numref">Fig. 5</span></a> shows that under the worst-case scenario, the number of steps in the binary search increases by one each time when the number of elements doubles.</p>
<p><span class="math notranslate nohighlight">\(log_2N\)</span> is calculated as <span class="math notranslate nohighlight">\(log_{10} N \over log_{10}2\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the number of elements in an array. If there are 1000 elements, the binary search would take 10 steps to perform the search. Remember the result is rounded up to the nearest decimal integer.</p>
<blockquote>
<div><p><strong>Remember that sorted arrays are only efficient in some scenarios. As we discussed, insertion in sorted arrays is slower than in unsorted arrays. However, there is a tradeoff in speed; slower insertion but fast search. If an application performs many insertions but less searching, then unsorted arrays would be a better choice. It is up to the programmer to analyze and select the correct data structure.</strong></p>
</div></blockquote>
<figure class="align-default" id="linear-binary">
<a class="reference internal image-reference" href="_images/linear_binary_search.svg"><img alt="_images/linear_binary_search.svg" height="400px" src="_images/linear_binary_search.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5 </span><span class="caption-text">Linear and binary search comparison</span><a class="headerlink" href="#linear-binary" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="big-o-notations">
<h2>Big O Notations<a class="headerlink" href="#big-o-notations" title="Permalink to this headline">#</a></h2>
<p>As discussed previously, each algorithm’s efficiency is primarily based on the number of steps it takes. The number of steps an algorithm takes is based on the worst-case and best-case scenarios, and the number of elements in an array, and so on.</p>
<p>To help ease communication regarding time complexity, computer scientists have borrowed a concept from the world of mathematics to describe a concise and consistent language around the efficiency of data structures and algorithms, as known as Big O Notation.</p>
<div class="alert alert-block alert-info">
In computer science, big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows.
</div>
<p>In other words, big O notation is used to compare efficiencies between algorithms to achieve a task. It’s the letter O not the number 0. So what does the O stand for? ‘Order’, or ‘order of complexity’. For example, as discussed before that the linear search takes N steps. Therefore, in the language of big O notation, the linear search algorithm is expressed as O(N). The efficiency of each algorithm is dependent upon a scenario. I defined scenarios as worst-case, average-case, and best-case scenarios. For example, under a linear search algorithm, if the search element is the first element in the array, the complexity will be O(1). On the contrary, the complexity will be O(N) if the search element is the last element in the array. Generally speaking, the algorithm’s efficiency is gauged under the worst-case scenario.</p>
<blockquote>
<div><p><strong>The above is more of a conservative approach. However, if you know how inefficient an algorithm can get in a worst-case scenario, the better we are prepared for the worst and may strongly impact our choices.</strong></p>
</div></blockquote>
<p>O(1) algorithm complexity is independent of the number of elements in an array. For example, the complexity of inserting an element in an unsorted array is O(1) because it will take only a step to insert the element without shifting an element.</p>
<blockquote>
<div><p><strong>Big O tells you how the number of steps increases as the data changes.</strong></p>
</div></blockquote>
<p><a class="reference internal" href="#bigocomparisons"><span class="std std-numref">Fig. 6</span></a> is a comparison between time complexity of <span class="math notranslate nohighlight">\(O(n)\)</span>, <span class="math notranslate nohighlight">\(O(log_2n)\)</span> and <span class="math notranslate nohighlight">\(O(1)\)</span>. The comparison suggests that an algorithm with a time complexity of <span class="math notranslate nohighlight">\(O(log_2n)\)</span> always performs better than <span class="math notranslate nohighlight">\(O(n)\)</span>. Furthermore, the complexity of <span class="math notranslate nohighlight">\(O(1)\)</span> will always perform better regardless of n.</p>
<figure class="align-default" id="bigocomparisons">
<a class="reference internal image-reference" href="_images/bigocomparisons.svg"><img alt="_images/bigocomparisons.svg" height="400px" src="_images/bigocomparisons.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">Big O comparisons between O(n), O(log n), and O(1)</span><a class="headerlink" href="#bigocomparisons" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="o-1-example">
<h3><span class="math notranslate nohighlight">\(O(1)\)</span> example<a class="headerlink" href="#o-1-example" title="Permalink to this headline">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot; Code written in Python &quot;&quot;&quot;</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;apples&quot;</span><span class="p">,</span><span class="s2">&quot;oranges&quot;</span><span class="p">,</span><span class="s2">&quot;grapes&quot;</span><span class="p">,</span><span class="s2">&quot;pineapple&quot;</span><span class="p">]</span>
<span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;kiwi&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>In the above example, a new element is appended at the end of the list. The insertion of a new element does not require any shifting of elements. Furthermore, the data is printed at index 0.</p>
</section>
<section id="o-n-example">
<h3><span class="math notranslate nohighlight">\(O(n)\)</span> example<a class="headerlink" href="#o-n-example" title="Permalink to this headline">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot; Code written in Python &quot;&quot;&quot;</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;apples&quot;</span><span class="p">,</span><span class="s2">&quot;oranges&quot;</span><span class="p">,</span><span class="s2">&quot;grapes&quot;</span><span class="p">,</span><span class="s2">&quot;pineapple&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above example, a list is defined, and the for loop iterates over the list and prints the element in each iteration. Hence, the for loop will run equal to the length of the list. This is an example of <span class="math notranslate nohighlight">\(O(n)\)</span> complexity.</p>
</section>
<section id="o-log-2n-example">
<h3><span class="math notranslate nohighlight">\(O(log_2n)\)</span> example<a class="headerlink" href="#o-log-2n-example" title="Permalink to this headline">#</a></h3>
</section>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">#</a></h2>
<p>There is no single algorithm that is perfect for every situation. For example, sorted arrays provide improvements in terms of searching an element using a binary search; however, at the cost of increasing complexity when inserting elements in the sorted array. On the contrary, if adding data is the main task, standard arrays may be a better choice due to the faster insertion rate. The Big-O notation is used to find the worst-case scenario of the time it takes an algorithm to do its job.</p>
</section>
<section id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">#</a></h2>
<div class="docutils container" id="id3">
<dl class="citation">
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id2">Knu98</a></span></dt>
<dd><p>Donald Knuth. <em>The Art of Computer Programming</em>. Volume 3. Addison-Wesley Professional, 1998. ISBN 978-0-201-89685-5.</p>
</dd>
</dl>
</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="binarysearch"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_algorithm#/media/File:Binary-search-work.gif">https://en.wikipedia.org/wiki/Binary_search_algorithm#/media/File:Binary-search-work.gif</a></p>
</dd>
</dl>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="Data_structures.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Why learn data structures?</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Sorting_algorithms.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Sorting algorithms</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Danish Khan<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>